{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/schema.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tBetterAuthPluginDBSchema,\n\tDBFieldAttribute,\n} from \"@better-auth/core/db\";\nimport { APIError } from \"better-call\";\nimport type { Account, Session, User } from \"../types\";\n\n// Cache for parsed schemas to avoid reparsing on every request\nconst cache = new WeakMap<\n\tBetterAuthOptions,\n\tMap<string, Record<string, DBFieldAttribute>>\n>();\n\nfunction parseOutputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t},\n) {\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (field.returned === false) {\n\t\t\tcontinue;\n\t\t}\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData as T;\n}\n\nfunction getAllFields(options: BetterAuthOptions, table: string) {\n\tif (!cache.has(options)) {\n\t\tcache.set(options, new Map());\n\t}\n\tconst tableCache = cache.get(options)!;\n\tif (tableCache.has(table)) {\n\t\treturn tableCache.get(table)!;\n\t}\n\tlet schema: Record<string, DBFieldAttribute> = {\n\t\t...(table === \"user\" ? options.user?.additionalFields : {}),\n\t\t...(table === \"session\" ? options.session?.additionalFields : {}),\n\t};\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.schema && plugin.schema[table]) {\n\t\t\tschema = {\n\t\t\t\t...schema,\n\t\t\t\t...plugin.schema[table].fields,\n\t\t\t};\n\t\t}\n\t}\n\tcache.get(options)!.set(table, schema);\n\treturn schema;\n}\n\nexport function parseUserOutput(options: BetterAuthOptions, user: User) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn {\n\t\t...parseOutputData(user, { fields: schema }),\n\t\tid: user.id,\n\t};\n}\n\nexport function parseAccountOutput(\n\toptions: BetterAuthOptions,\n\taccount: Account,\n) {\n\tconst schema = getAllFields(options, \"account\");\n\treturn parseOutputData(account, { fields: schema });\n}\n\nexport function parseSessionOutput(\n\toptions: BetterAuthOptions,\n\tsession: Session,\n) {\n\tconst schema = getAllFields(options, \"session\");\n\treturn parseOutputData(session, { fields: schema });\n}\n\nexport function parseInputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\taction?: (\"create\" | \"update\") | undefined;\n\t},\n) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = Object.assign(\n\t\tObject.create(null),\n\t\tnull,\n\t);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key]!.input === false) {\n\t\t\t\tif (fields[key]!.defaultValue !== undefined) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: `${key} is not allowed to be set`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.validator?.input && data[key] !== undefined) {\n\t\t\t\tconst result = fields[key]!.validator.input[\"~standard\"].validate(\n\t\t\t\t\tdata[key],\n\t\t\t\t);\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Async validation is not supported for additional fields\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (\"issues\" in result && result.issues) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: result.issues[0]?.message || \"Validation Error\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tparsedData[key] = result.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.transform?.input && data[key] !== undefined) {\n\t\t\t\tparsedData[key] = fields[key]!.transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.defaultValue !== undefined && action === \"create\") {\n\t\t\tif (typeof fields[key]!.defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key]!.defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.required && action === \"create\") {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `${key} is required`,\n\t\t\t});\n\t\t}\n\t}\n\treturn parsedData as Partial<T>;\n}\n\nexport function parseUserInput(\n\toptions: BetterAuthOptions,\n\tuser: Record<string, any> = {},\n\taction: \"create\" | \"update\",\n) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn parseInputData(user, { fields: schema, action });\n}\n\nexport function parseAdditionalUserInput(\n\toptions: BetterAuthOptions,\n\tuser?: Record<string, any> | undefined,\n) {\n\tconst schema = getAllFields(options, \"user\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\n\nexport function parseAccountInput(\n\toptions: BetterAuthOptions,\n\taccount: Partial<Account>,\n) {\n\tconst schema = getAllFields(options, \"account\");\n\treturn parseInputData(account, { fields: schema });\n}\n\nexport function parseSessionInput(\n\toptions: BetterAuthOptions,\n\tsession: Partial<Session>,\n) {\n\tconst schema = getAllFields(options, \"session\");\n\treturn parseInputData(session, { fields: schema });\n}\n\nexport function mergeSchema<S extends BetterAuthPluginDBSchema>(\n\tschema: S,\n\tnewSchema?:\n\t\t| {\n\t\t\t\t[K in keyof S]?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tmodelName?: string | undefined;\n\t\t\t\t\t\t\tfields?:\n\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t[P: string]: string;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tif (!newSchema) {\n\t\treturn schema;\n\t}\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) {\n\t\t\tschema[table]!.modelName = newModelName;\n\t\t}\n\t\tfor (const field in schema[table]!.fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tschema[table]!.fields[field]!.fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n"],"names":["parsedData: Record<string, any>","schema: Record<string, DBFieldAttribute>"],"mappings":"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"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/adapter-base.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/adapter-base.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport type { MemoryDB } from \"../adapters/memory-adapter\";\n\nexport async function getBaseAdapter(\n\toptions: BetterAuthOptions,\n\thandleDirectDatabase: (\n\t\toptions: BetterAuthOptions,\n\t) => Promise<DBAdapter<BetterAuthOptions>>,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\tlet adapter: DBAdapter<BetterAuthOptions>;\n\n\tif (!options.database) {\n\t\tconst tables = getAuthTables(options);\n\t\tconst memoryDB = Object.keys(tables).reduce<MemoryDB>((acc, key) => {\n\t\t\tacc[key] = [];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst { memoryAdapter } = await import(\"../adapters/memory-adapter\");\n\t\tadapter = memoryAdapter(memoryDB)(options);\n\t} else if (typeof options.database === \"function\") {\n\t\tadapter = options.database(options);\n\t} else {\n\t\tadapter = await handleDirectDatabase(options);\n\t}\n\n\t// patch for 1.3.x to ensure we have a transaction function in the adapter\n\tif (!adapter.transaction) {\n\t\tlogger.warn(\n\t\t\t\"Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.\",\n\t\t);\n\t\tadapter.transaction = async (cb) => {\n\t\t\treturn cb(adapter);\n\t\t};\n\t}\n\n\treturn adapter;\n}\n"],"names":["adapter: DBAdapter<BetterAuthOptions>"],"mappings":";;;;;;;;;;;AAMA,eAAsB,eACrB,OAAA,EACA,oBAAA,EAGwC;IACxC,IAAIA;IAEJ,IAAI,CAAC,QAAQ,QAAA,EAAU;QACtB,MAAM,aAAS,obAAA,EAAc,QAAQ;QACrC,MAAM,WAAW,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAkB,KAAK,QAAQ;YACnE,GAAA,CAAI,IAAA,GAAO,EAAE;YACb,OAAO;WACL,CAAA,CAAE,CAAC;QACN,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,UAAU,cAAc,SAAS,CAAC,QAAQ;eAChC,OAAO,QAAQ,QAAA,KAAa,WACtC,CAAA,UAAU,QAAQ,QAAA,CAAS,QAAQ;SAEnC,UAAU,MAAM,qBAAqB,QAAQ;IAI9C,IAAI,CAAC,QAAQ,WAAA,EAAa;QACzB,4ZAAA,CAAO,IAAA,CACN,mIACA;QACD,QAAQ,WAAA,GAAc,OAAO,OAAO;YACnC,OAAO,GAAG,QAAQ;;;IAIpB,OAAO"}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/adapter-kysely.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/adapter-kysely.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { getBaseAdapter } from \"./adapter-base\";\n\nexport async function getAdapter(\n\toptions: BetterAuthOptions,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\treturn getBaseAdapter(options, async (opts) => {\n\t\tconst { createKyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\tconst { kysely, databaseType, transaction } =\n\t\t\tawait createKyselyAdapter(opts);\n\t\tif (!kysely) {\n\t\t\tthrow new BetterAuthError(\"Failed to initialize database adapter\");\n\t\t}\n\t\tconst { kyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\treturn kyselyAdapter(kysely, {\n\t\t\ttype: databaseType || \"sqlite\",\n\t\t\tdebugLogs:\n\t\t\t\topts.database && \"debugLogs\" in opts.database\n\t\t\t\t\t? opts.database.debugLogs\n\t\t\t\t\t: false,\n\t\t\ttransaction: transaction,\n\t\t})(opts);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;;;;AAKA,eAAsB,WACrB,OAAA,EACwC;IACxC,WAAO,gYAAA,EAAe,SAAS,OAAO,SAAS;QAC9C,MAAM,EAAE,mBAAA,EAAA,GAAwB,MAAM,OAAO;QAC7C,MAAM,EAAE,MAAA,EAAQ,YAAA,EAAc,WAAA,EAAA,GAC7B,MAAM,oBAAoB,KAAK;QAChC,IAAI,CAAC,OACJ,CAAA,MAAM,IAAI,gbAAA,CAAgB,wCAAwC;QAEnE,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,OAAO,cAAc,QAAQ;YAC5B,MAAM,gBAAgB;YACtB,WACC,KAAK,QAAA,IAAY,eAAe,KAAK,QAAA,GAClC,KAAK,QAAA,CAAS,SAAA,GACd;YACS;SACb,CAAC,CAAC,KAAK;MACP"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/field.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/field.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tDBFieldAttribute,\n\tDBFieldAttributeConfig,\n\tDBFieldType,\n} from \"@better-auth/core/db\";\n\nexport const createFieldAttribute = <\n\tT extends DBFieldType,\n\tC extends DBFieldAttributeConfig,\n>(\n\ttype: T,\n\tconfig?: C | undefined,\n) => {\n\treturn {\n\t\ttype,\n\t\t...config,\n\t} satisfies DBFieldAttribute<T>;\n};\n\nexport type InferValueType<T extends DBFieldType> = T extends \"string\"\n\t? string\n\t: T extends \"number\"\n\t\t? number\n\t\t: T extends \"boolean\"\n\t\t\t? boolean\n\t\t\t: T extends \"date\"\n\t\t\t\t? Date\n\t\t\t\t: T extends \"json\"\n\t\t\t\t\t? Record<string, any>\n\t\t\t\t\t: T extends `${infer U}[]`\n\t\t\t\t\t\t? U extends \"string\"\n\t\t\t\t\t\t\t? string[]\n\t\t\t\t\t\t\t: number[]\n\t\t\t\t\t\t: T extends Array<any>\n\t\t\t\t\t\t\t? T[number]\n\t\t\t\t\t\t\t: never;\n\nexport type InferFieldsOutput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: key]: InferFieldOutput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key\n\t\t\t\t\t\t: never]?: InferFieldOutput<Field[key]> | null;\n\t\t\t}\n\t\t: {};\n\nexport type InferFieldsInput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false ? never : key]?:\n\t\t\t\t\t| InferFieldInput<Field[key]>\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null;\n\t\t\t}\n\t\t: {};\n\n/**\n * For client will add \"?\" on optional fields\n */\nexport type InferFieldsInputClient<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? key\n\t\t\t\t\t\t: Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never]?: InferFieldInput<Field[key]> | undefined | null;\n\t\t\t}\n\t\t: {};\n\ntype InferFieldOutput<T extends DBFieldAttribute> = T[\"returned\"] extends false\n\t? never\n\t: T[\"required\"] extends false\n\t\t? InferValueType<T[\"type\"]> | undefined | null\n\t\t: InferValueType<T[\"type\"]>;\n\n/**\n * Converts a Record<string, DBFieldAttribute> to an object type\n * with keys and value types inferred from DBFieldAttribute[\"type\"].\n */\nexport type FieldAttributeToObject<\n\tFields extends Record<string, DBFieldAttribute>,\n> = AddOptionalFields<\n\t{\n\t\t[K in keyof Fields]: InferValueType<Fields[K][\"type\"]>;\n\t},\n\tFields\n>;\n\ntype AddOptionalFields<\n\tT extends Record<string, any>,\n\tFields extends Record<keyof T, DBFieldAttribute>,\n> = {\n\t// Required fields: required === true\n\t[K in keyof T as Fields[K] extends { required: true } ? K : never]: T[K];\n} & {\n\t// Optional fields: required !== true\n\t[K in keyof T as Fields[K] extends { required: true } ? never : K]?: T[K];\n};\n\n/**\n * Infer the additional fields from the plugin options.\n * For example, you can infer the additional fields of the org plugin's organization schema like this:\n * ```ts\n * type AdditionalFields = InferAdditionalFieldsFromPluginOptions<\"organization\", OrganizationOptions>\n * ```\n */\nexport type InferAdditionalFieldsFromPluginOptions<\n\tSchemaName extends string,\n\tOptions extends {\n\t\tschema?:\n\t\t\t| {\n\t\t\t\t\t[key in SchemaName]?: {\n\t\t\t\t\t\tadditionalFields?: Record<string, DBFieldAttribute>;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t},\n\tisClientSide extends boolean = true,\n> = Options[\"schema\"] extends {\n\t[key in SchemaName]?: {\n\t\tadditionalFields: infer Field extends Record<string, DBFieldAttribute>;\n\t};\n}\n\t? isClientSide extends true\n\t\t? FieldAttributeToObject<RemoveFieldsWithInputFalse<Field>>\n\t\t: FieldAttributeToObject<Field>\n\t: {};\n\ntype RemoveFieldsWithInputFalse<T extends Record<string, DBFieldAttribute>> = {\n\t[K in keyof T as T[K][\"input\"] extends false ? never : K]: T[K];\n};\n\ntype InferFieldInput<T extends DBFieldAttribute> = InferValueType<T[\"type\"]>;\n\nexport type PluginFieldAttribute = Omit<\n\tDBFieldAttribute,\n\t\"transform\" | \"defaultValue\" | \"hashValue\"\n>;\n\nexport type InferFieldsFromPlugins<\n\tOptions extends BetterAuthOptions,\n\tKey extends string,\n\tFormat extends \"output\" | \"input\",\n> = Options[\"plugins\"] extends []\n\t? {}\n\t: Options[\"plugins\"] extends Array<infer T>\n\t\t? T extends {\n\t\t\t\tschema: {\n\t\t\t\t\t[key in Key]: {\n\t\t\t\t\t\tfields: infer Field;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t\t? Format extends \"output\"\n\t\t\t\t? InferFieldsOutput<Field>\n\t\t\t\t: InferFieldsInput<Field>\n\t\t\t: {}\n\t\t: {};\n\nexport type InferFieldsFromOptions<\n\tOptions extends BetterAuthOptions,\n\tKey extends \"session\" | \"user\",\n\tFormat extends \"output\" | \"input\",\n> = Options[Key] extends {\n\tadditionalFields: infer Field;\n}\n\t? Format extends \"output\"\n\t\t? InferFieldsOutput<Field>\n\t\t: InferFieldsInput<Field>\n\t: {};\n"],"names":[],"mappings":";;;;;AAOA,MAAa,uBAAA,CAIZ,MACA,WACI;IACJ,OAAO;QACN;QACA,GAAG,MAAA;KACH"}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/field-converter.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/field-converter.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\n\nexport function convertToDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T,\n) {\n\tlet result: Record<string, any> = values.id\n\t\t? {\n\t\t\t\tid: values.id,\n\t\t\t}\n\t\t: {};\n\tfor (const key in fields) {\n\t\tconst field = fields[key]!;\n\t\tconst value = values[key];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult[field.fieldName || key] = value;\n\t}\n\treturn result as T;\n}\n\nexport function convertFromDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T | null,\n) {\n\tif (!values) {\n\t\treturn null;\n\t}\n\tlet result: Record<string, any> = {\n\t\tid: values.id,\n\t};\n\tfor (const [key, value] of Object.entries(fields)) {\n\t\tresult[key] = values[value.fieldName || key];\n\t}\n\treturn result as T;\n}\n"],"names":["result: Record<string, any>"],"mappings":";;;;;;;AAEA,SAAgB,YACf,MAAA,EACA,MAAA,EACC;IACD,IAAIA,SAA8B,OAAO,EAAA,GACtC;QACA,IAAI,OAAO,EAAA;IAAA,CACX,GACA,CAAA,CAAE;IACL,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,UAAU,KAAA,EACb,CAAA;QAED,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA,GAAO;;IAElC,OAAO;;AAGR,SAAgB,cACf,MAAA,EACA,MAAA,EACC;IACD,IAAI,CAAC,OACJ,CAAA,OAAO;IAER,IAAIA,SAA8B;QACjC,IAAI,OAAO,EAAA;IAAA,CACX;IACD,KAAK,MAAM,CAAC,KAAK,MAAA,IAAU,OAAO,OAAA,CAAQ,OAAO,CAChD,MAAA,CAAO,IAAA,GAAO,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA;IAEzC,OAAO"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/with-hooks.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/with-hooks.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n} from \"@better-auth/core/context\";\nimport type { BaseModelNames } from \"@better-auth/core/db\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\n\nexport function getWithHooks(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: BetterAuthOptions;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t},\n) {\n\tconst hooks = ctx.hooks;\n\tasync function createWithHooks<T extends Record<string, any>>(\n\t\tdata: T,\n\t\tmodel: BaseModelNames,\n\t\tcustomCreateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(actualData as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customCreated = customCreateFn\n\t\t\t? await customCreateFn.fn(actualData)\n\t\t\t: null;\n\t\tconst created =\n\t\t\t!customCreateFn || customCreateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).create<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: actualData as any,\n\t\t\t\t\t\tforceAllowId: true,\n\t\t\t\t\t})\n\t\t\t\t: customCreated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(created as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tasync function updateWithHooks<T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).update<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\tasync function updateManyWithHooks<_T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\tasync function deleteWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entityToDelete: T | null = null;\n\n\t\ttry {\n\t\t\tconst entities = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tentityToDelete = entities[0] || null;\n\t\t} catch {\n\t\t\t// If we can't find the entity, we'll still proceed with deletion\n\t\t}\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entityToDelete as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).delete({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entityToDelete as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\tasync function deleteManyWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entitiesToDelete: T[] = [];\n\n\t\ttry {\n\t\t\tentitiesToDelete = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t});\n\t\t} catch {\n\t\t\t// If we can't find the entities, we'll still proceed with deletion\n\t\t}\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entity as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entity as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\treturn {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t};\n}\n"],"names":["entityToDelete: T | null","entitiesToDelete: T[]"],"mappings":"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"}},
    {"offset": {"line": 439, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/internal-adapter.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/internal-adapter.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tInternalAdapter,\n} from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n\trunWithTransaction,\n} from \"@better-auth/core/context\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { generateId, safeJSONParse } from \"@better-auth/core/utils\";\nimport type { Account, Session, User, Verification } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { getIp } from \"../utils/get-request-ip\";\nimport {\n\tparseSessionInput,\n\tparseSessionOutput,\n\tparseUserOutput,\n} from \"./schema\";\nimport { getWithHooks } from \"./with-hooks\";\n\nexport const createInternalAdapter = (\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: Omit<BetterAuthOptions, \"logger\">;\n\t\tlogger: InternalLogger;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t\tgenerateId: AuthContext[\"generateId\"];\n\t},\n): InternalAdapter => {\n\tconst logger = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7; // 7 days\n\tconst {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t} = getWithHooks(adapter, ctx);\n\n\tasync function refreshUserSessions(user: User) {\n\t\tif (!secondaryStorage) return;\n\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\n\t\tconst now = Date.now();\n\t\tconst list =\n\t\t\tsafeJSONParse<{ token: string; expiresAt: number }[]>(listRaw) || [];\n\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\n\t\tawait Promise.all(\n\t\t\tvalidSessions.map(async ({ token }) => {\n\t\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\t\tif (!cached) return;\n\t\t\t\tconst parsed = safeJSONParse<{ session: Session; user: User }>(cached);\n\t\t\t\tif (!parsed) return;\n\n\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\tMath.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1000,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\ttoken,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tsession: parsed.session,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t}),\n\t\t\t\t\tMath.floor(sessionTTL),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\tcreateOAuthUser: async (\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">,\n\t\t\taccount: Omit<Account, \"userId\" | \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t...user,\n\t\t\t\t\t},\n\t\t\t\t\t\"user\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser!.id,\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t},\n\t\t\t\t\t\"account\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: createdAccount,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async <T>(\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\" | \"emailVerified\"> &\n\t\t\t\tPartial<User> &\n\t\t\t\tRecord<string, any>,\n\t\t) => {\n\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...user,\n\t\t\t\t\temail: user.email?.toLowerCase(),\n\t\t\t\t},\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\treturn createdUser as T & User;\n\t\t},\n\t\tcreateAccount: async <T extends Record<string, any>>(\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account> &\n\t\t\t\tT,\n\t\t) => {\n\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn createdAccount as T & Account;\n\t\t},\n\t\tlistSessions: async (userId: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t);\n\t\t\t\tif (!currentList) return [];\n\n\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\t\t\t\tconst sessions = [];\n\n\t\t\t\tfor (const session of validSessions) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(session.token);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\t\tif (!s) return [];\n\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsessions.push(parsedSession);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Session>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn sessions;\n\t\t},\n\t\tlistUsers: async (\n\t\t\tlimit?: number | undefined,\n\t\t\toffset?: number | undefined,\n\t\t\tsortBy?:\n\t\t\t\t| {\n\t\t\t\t\t\tfield: string;\n\t\t\t\t\t\tdirection: \"asc\" | \"desc\";\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\twhere?: Where[] | undefined,\n\t\t) => {\n\t\t\tconst users = await (await getCurrentAdapter(adapter)).findMany<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere,\n\t\t\t});\n\t\t\treturn users;\n\t\t},\n\t\tcountTotalUsers: async (where?: Where[] | undefined) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere,\n\t\t\t});\n\t\t\tif (typeof total === \"string\") {\n\t\t\t\treturn parseInt(total);\n\t\t\t}\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId: string) => {\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"session\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tcreateSession: async (\n\t\t\tuserId: string,\n\t\t\tdontRememberMe?: boolean | undefined,\n\t\t\toverride?: (Partial<Session> & Record<string, any>) | undefined,\n\t\t\toverrideAll?: boolean | undefined,\n\t\t) => {\n\t\t\tconst ctx = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx?.headers || ctx?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\t//we're parsing default values for session additional fields\n\t\t\tconst defaultAdditionalFields = parseSessionInput(\n\t\t\t\tctx?.context.options ?? options,\n\t\t\t\t{},\n\t\t\t);\n\t\t\tconst data: Omit<Session, \"id\"> = {\n\t\t\t\tipAddress:\n\t\t\t\t\tctx?.request || ctx?.headers\n\t\t\t\t\t\t? getIp(ctx?.request || ctx?.headers!, ctx?.context.options) || \"\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\t/**\n\t\t\t\t * If the user doesn't want to be remembered\n\t\t\t\t * set the session to expire in 1 day.\n\t\t\t\t * The cookie will be set to expire at the end of the session\n\t\t\t\t */\n\t\t\t\texpiresAt: dontRememberMe\n\t\t\t\t\t? getDate(60 * 60 * 24, \"sec\") // 1 day\n\t\t\t\t\t: getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...(overrideAll ? rest : {}),\n\t\t\t};\n\t\t\tconst res = await createWithHooks(\n\t\t\t\tdata,\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * store the session token for the user\n\t\t\t\t\t\t\t\t * so we can retrieve it later for listing sessions\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] = [];\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\t\t\t\tlist = list.filter((session) => session.expiresAt > now);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst sorted = list.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\t\t\tlet furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\t\t\tsorted.push({\n\t\t\t\t\t\t\t\t\ttoken: data.token,\n\t\t\t\t\t\t\t\t\texpiresAt: data.expiresAt.getTime(),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!furthestSessionExp ||\n\t\t\t\t\t\t\t\t\tfurthestSessionExp < data.expiresAt.getTime()\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tfurthestSessionExp = data.expiresAt.getTime();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst furthestSessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (furthestSessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\tfurthestSessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst user = await adapter.findOne<User>({\n\t\t\t\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((data.expiresAt.getTime() - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tdata.token,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn sessionData;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn res as Session;\n\t\t},\n\t\tfindSession: async (\n\t\t\ttoken: string,\n\t\t): Promise<{\n\t\t\tsession: Session & Record<string, any>;\n\t\t\tuser: User & Record<string, any>;\n\t\t} | null> => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.options, {\n\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: token,\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\tconst parsedSession = parseSessionOutput(ctx.options, session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.options, user);\n\t\t\treturn {\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser,\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens: string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[] = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\t\tif (!s) return [];\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsessions.push(session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\t\toperator: \"in\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user!,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (\n\t\t\tsessionToken: string,\n\t\t\tsession: Partial<Session> & Record<string, any>,\n\t\t) => {\n\t\t\tconst updatedSession = await updateWithHooks<Session>(\n\t\t\t\tsession,\n\t\t\t\t[{ field: \"token\", value: sessionToken }],\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tasync fn(data) {\n\t\t\t\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\t\t\tlet updatedSession: Session | null = null;\n\t\t\t\t\t\t\t\tif (currentSession) {\n\t\t\t\t\t\t\t\t\tconst parsedSession = safeJSONParse<{\n\t\t\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\t\t}>(currentSession);\n\t\t\t\t\t\t\t\t\tif (!parsedSession) return null;\n\t\t\t\t\t\t\t\t\tupdatedSession = {\n\t\t\t\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn updatedSession;\n\t\t},\n\t\tdeleteSession: async (token: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\t// remove the session from the active sessions list\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } =\n\t\t\t\t\t\tsafeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\n\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] =\n\t\t\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\tconst filtered = list.filter(\n\t\t\t\t\t\t\t(session) => session.expiresAt > now && session.token !== token,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst sorted = filtered.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tfiltered.length > 0 &&\n\t\t\t\t\t\t\tfurthestSessionExp &&\n\t\t\t\t\t\t\tfurthestSessionExp > Date.now()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\tJSON.stringify(filtered),\n\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait secondaryStorage.delete(token);\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"token\", value: token }],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccounts: async (userId: string) => {\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccount: async (accountId: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: accountId }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens: string | string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t\tconst sessions = activeSession\n\t\t\t\t\t\t? safeJSONParse<{ token: string }[]>(activeSession)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\t\tawait secondaryStorage.delete(session.token);\n\t\t\t\t\t}\n\t\t\t\t\tawait secondaryStorage.delete(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const sessionToken of userIdOrSessionTokens) {\n\t\t\t\t\t\tconst session = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\tif (session) {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(sessionToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindOAuthUser: async (\n\t\t\temail: string,\n\t\t\taccountId: string,\n\t\t\tproviderId: string,\n\t\t) => {\n\t\t\t// we need to find account first to avoid missing user if the email changed with the provider for the same account\n\t\t\tconst account = await (await getCurrentAdapter(adapter))\n\t\t\t\t.findMany<Account & { user: User | null }>({\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tjoin: {\n\t\t\t\t\t\tuser: true,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\t.then((accounts) => {\n\t\t\t\t\treturn accounts.find((a) => a.providerId === providerId);\n\t\t\t\t});\n\t\t\tif (account) {\n\t\t\t\tif (account.user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: account.user,\n\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tif (user) {\n\t\t\t\t\tconst accounts = await (\n\t\t\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t\t\t).findMany<Account>({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\taccounts: accounts || [],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (\n\t\t\temail: string,\n\t\t\toptions?: { includeAccounts: boolean } | undefined,\n\t\t) => {\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tUser & { account: Account[] | undefined }\n\t\t\t>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\t...(options?.includeAccounts ? { account: true } : {}),\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? [],\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId: string) => {\n\t\t\tif (!userId) return null;\n\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn user;\n\t\t},\n\t\tlinkAccount: async (\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\tconst _account = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn _account;\n\t\t},\n\t\tupdateUser: async (\n\t\t\tuserId: string,\n\t\t\tdata: Partial<User> & Record<string, any>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (\n\t\t\temail: string,\n\t\t\tdata: Partial<User & Record<string, any>>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId: string, password: string) => {\n\t\t\tawait updateManyWithHooks(\n\t\t\t\t{\n\t\t\t\t\tpassword,\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindAccounts: async (userId: string) => {\n\t\t\tconst accounts = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn accounts;\n\t\t},\n\t\tfindAccount: async (accountId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByProviderId: async (accountId: string, providerId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByUserId: async (userId: string) => {\n\t\t\tconst account = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn account;\n\t\t},\n\t\tupdateAccount: async (id: string, data: Partial<Account>) => {\n\t\t\tconst account = await updateWithHooks<Account>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tcreateVerificationValue: async (\n\t\t\tdata: Omit<Verification, \"createdAt\" | \"id\" | \"updatedAt\"> &\n\t\t\t\tPartial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification as Verification;\n\t\t},\n\t\tfindVerificationValue: async (identifier: string) => {\n\t\t\tconst verification = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Verification>({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\t\tvalue: identifier,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\",\n\t\t\t\t},\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\t\t\tvalue: new Date(),\n\t\t\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"verification\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lastVerification = verification[0];\n\t\t\treturn lastVerification as Verification | null;\n\t\t},\n\t\tdeleteVerificationValue: async (id: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"identifier\", value: identifier }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tupdateVerificationValue: async (\n\t\t\tid: string,\n\t\t\tdata: Partial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await updateWithHooks<Verification>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification;\n\t\t},\n\t};\n};\n"],"names":["list: { token: string; expiresAt: number }[]","ctx","data: Omit<Session, \"id\">","sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[]","sessions","updatedSession: Session | null","session","options"],"mappings":"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"}},
    {"offset": {"line": 1082, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/to-zod.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/to-zod.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport type { ZodType } from \"zod\";\nimport * as z from \"zod\";\n\nexport function toZodSchema<\n\tFields extends Record<string, DBFieldAttribute | never>,\n\tIsClientSide extends boolean,\n>({\n\tfields,\n\tisClientSide,\n}: {\n\tfields: Fields;\n\t/**\n\t * If true, then any fields that have `input: false` will be removed from the schema to prevent user input.\n\t */\n\tisClientSide: IsClientSide;\n}) {\n\tconst zodFields = Object.keys(fields).reduce((acc, key) => {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\treturn acc;\n\t\t}\n\t\tif (isClientSide && field.input === false) {\n\t\t\treturn acc;\n\t\t}\n\n\t\tlet schema: ZodType;\n\t\tif (field.type === \"json\") {\n\t\t\tschema = (z as any).json ? (z as any).json() : z.any();\n\t\t} else if (field.type === \"string[]\" || field.type === \"number[]\") {\n\t\t\tschema = z.array(field.type === \"string[]\" ? z.string() : z.number());\n\t\t} else if (Array.isArray(field.type)) {\n\t\t\tschema = z.any();\n\t\t} else {\n\t\t\tschema = z[field.type]();\n\t\t}\n\n\t\tif (field?.required === false) {\n\t\t\tschema = schema.optional();\n\t\t}\n\t\tif (field?.returned === false) {\n\t\t\treturn acc;\n\t\t}\n\t\treturn {\n\t\t\t...acc,\n\t\t\t[key]: schema,\n\t\t};\n\t}, {});\n\tconst schema = z.object(zodFields);\n\treturn schema as z.ZodObject<\n\t\tRemoveNeverProps<{\n\t\t\t[key in keyof Fields]: FieldAttributeToSchema<Fields[key], IsClientSide>;\n\t\t}>,\n\t\tz.core.$strip\n\t>;\n}\n\nexport type FieldAttributeToSchema<\n\tField extends DBFieldAttribute | Record<string, never>,\n\t// if it's client side, then field attributes of `input` that are false should be removed\n\tisClientSide extends boolean = false,\n> = Field extends { type: any }\n\t? GetInput<isClientSide, Field, GetRequired<Field, GetType<Field>>>\n\t: Record<string, never>;\n\ntype GetType<F extends DBFieldAttribute> = F extends {\n\ttype: \"string\";\n}\n\t? z.ZodString\n\t: F extends { type: \"number\" }\n\t\t? z.ZodNumber\n\t\t: F extends { type: \"boolean\" }\n\t\t\t? z.ZodBoolean\n\t\t\t: F extends { type: \"date\" }\n\t\t\t\t? z.ZodDate\n\t\t\t\t: z.ZodAny;\n\ntype GetRequired<\n\tF extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = F extends {\n\trequired: true;\n}\n\t? Schema\n\t: z.ZodOptional<Schema>;\n\ntype GetInput<\n\tisClientSide extends boolean,\n\tField extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = Field extends {\n\tinput: false;\n}\n\t? isClientSide extends true\n\t\t? never\n\t\t: Schema\n\t: Schema;\n\ntype RemoveNeverProps<T> = {\n\t[K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\n"],"names":["schema: ZodType"],"mappings":";;;;;;;AAIA,SAAgB,YAGd,EACD,MAAA,EACA,YAAA,EAAA,EAOE;IACF,MAAM,YAAY,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAQ,KAAK,QAAQ;QAC1D,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,CAAC,MACJ,CAAA,OAAO;QAER,IAAI,gBAAgB,MAAM,KAAA,KAAU,MACnC,CAAA,OAAO;QAGR,IAAIA;QACJ,IAAI,MAAM,IAAA,KAAS,OAClB,CAAA,SAAU,+KAAU,IAAA,GAAQ,+KAAU,IAAA,EAAM,GAAG,+KAAE,GAAA,EAAK;iBAC5C,MAAM,IAAA,KAAS,cAAc,MAAM,IAAA,KAAS,WACtD,CAAA,SAAS,+KAAE,KAAA,CAAM,MAAM,IAAA,KAAS,aAAa,+KAAE,MAAA,EAAQ,GAAG,+KAAE,MAAA,EAAQ,CAAC;iBAC3D,MAAM,OAAA,CAAQ,MAAM,IAAA,CAAK,CACnC,CAAA,SAAS,+KAAE,GAAA,EAAK;aAEhB,SAAS,8KAAA,CAAE,MAAM,IAAA,CAAA,EAAO;QAGzB,IAAI,OAAO,aAAa,MACvB,CAAA,SAAS,OAAO,QAAA,EAAU;QAE3B,IAAI,OAAO,aAAa,MACvB,CAAA,OAAO;QAER,OAAO;YACN,GAAG,GAAA;aACF,IAAA,EAAM;SACP;OACC,CAAA,CAAE,CAAC;IAEN,OADe,+KAAE,MAAA,CAAO,UAAU"}},
    {"offset": {"line": 1114, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/get-schema.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/get-schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport { getAuthTables } from \".\";\n\nexport function getSchema(config: BetterAuthOptions) {\n\tconst tables = getAuthTables(config);\n\tlet schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t> = {};\n\tfor (const key in tables) {\n\t\tconst table = tables[key]!;\n\t\tconst fields = table.fields;\n\t\tlet actualFields: Record<string, DBFieldAttribute> = {};\n\t\tObject.entries(fields).forEach(([key, field]) => {\n\t\t\tactualFields[field.fieldName || key] = field;\n\t\t\tif (field.references) {\n\t\t\t\tconst refTable = tables[field.references.model];\n\t\t\t\tif (refTable) {\n\t\t\t\t\tactualFields[field.fieldName || key]!.references = {\n\t\t\t\t\t\t...field.references,\n\t\t\t\t\t\tmodel: refTable.modelName,\n\t\t\t\t\t\tfield: field.references.field,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (schema[table.modelName]) {\n\t\t\tschema[table.modelName]!.fields = {\n\t\t\t\t...schema[table.modelName]!.fields,\n\t\t\t\t...actualFields,\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\t\tschema[table.modelName] = {\n\t\t\tfields: actualFields,\n\t\t\torder: table.order || Infinity,\n\t\t};\n\t}\n\treturn schema;\n}\n"],"names":["schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t>","actualFields: Record<string, DBFieldAttribute>","key"],"mappings":";;;;;;;AAIA,SAAgB,UAAU,MAAA,EAA2B;IACpD,MAAM,SAAA,CAAA,GAAA,kYAAA,CAAA,aAAA,EAAuB,OAAO;IACpC,IAAIA,SAMA,CAAA,CAAE;IACN,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,SAAS,MAAM,MAAA;QACrB,IAAIC,eAAiD,CAAA,CAAE;QACvD,OAAO,OAAA,CAAQ,OAAO,CAAC,OAAA,CAAA,CAAS,CAACC,OAAK,MAAA,KAAW;YAChD,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,GAAO;YACvC,IAAI,MAAM,UAAA,EAAY;gBACrB,MAAM,WAAW,MAAA,CAAO,MAAM,UAAA,CAAW,KAAA,CAAA;gBACzC,IAAI,SACH,CAAA,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,CAAM,UAAA,GAAa;oBAClD,GAAG,MAAM,UAAA;oBACT,OAAO,SAAS,SAAA;oBAChB,OAAO,MAAM,UAAA,CAAW,KAAA;iBACxB;;UAGF;QACF,IAAI,MAAA,CAAO,MAAM,SAAA,CAAA,EAAY;YAC5B,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA,GAAS;gBACjC,GAAG,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA;gBAC5B,GAAG,YAAA;aACH;YACD;;QAED,MAAA,CAAO,MAAM,SAAA,CAAA,GAAa;YACzB,QAAQ;YACR,OAAO,MAAM,KAAA,IAAS;SACtB;;IAEF,OAAO"}},
    {"offset": {"line": 1159, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/get-migration.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/get-migration.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute, DBFieldType } from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport {\n\tinitGetFieldName,\n\tinitGetModelName,\n} from \"@better-auth/core/db/adapter\";\nimport { createLogger } from \"@better-auth/core/env\";\nimport type {\n\tAlterTableBuilder,\n\tAlterTableColumnAlteringBuilder,\n\tColumnDataType,\n\tCreateIndexBuilder,\n\tCreateTableBuilder,\n\tKysely,\n\tRawBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport { createKyselyAdapter } from \"../adapters/kysely-adapter/dialect\";\nimport type { KyselyDatabaseType } from \"../adapters/kysely-adapter/types\";\nimport { getSchema } from \"./get-schema\";\n\nconst postgresMap = {\n\tstring: [\"character varying\", \"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"int4\",\n\t\t\"integer\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"numeric\",\n\t\t\"real\",\n\t\t\"double precision\",\n\t],\n\tboolean: [\"bool\", \"boolean\"],\n\tdate: [\"timestamptz\", \"timestamp\", \"date\"],\n\tjson: [\"json\", \"jsonb\"],\n};\nconst mysqlMap = {\n\tstring: [\"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"integer\",\n\t\t\"int\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"decimal\",\n\t\t\"float\",\n\t\t\"double\",\n\t],\n\tboolean: [\"boolean\", \"tinyint\"],\n\tdate: [\"timestamp\", \"datetime\", \"date\"],\n\tjson: [\"json\"],\n};\n\nconst sqliteMap = {\n\tstring: [\"TEXT\"],\n\tnumber: [\"INTEGER\", \"REAL\"],\n\tboolean: [\"INTEGER\", \"BOOLEAN\"], // 0 or 1\n\tdate: [\"DATE\", \"INTEGER\"],\n\tjson: [\"TEXT\"],\n};\n\nconst mssqlMap = {\n\tstring: [\"varchar\", \"nvarchar\", \"uniqueidentifier\"],\n\tnumber: [\"int\", \"bigint\", \"smallint\", \"decimal\", \"float\", \"double\"],\n\tboolean: [\"bit\", \"smallint\"],\n\tdate: [\"datetime2\", \"date\", \"datetime\"],\n\tjson: [\"varchar\", \"nvarchar\"],\n};\n\nconst map = {\n\tpostgres: postgresMap,\n\tmysql: mysqlMap,\n\tsqlite: sqliteMap,\n\tmssql: mssqlMap,\n};\n\nexport function matchType(\n\tcolumnDataType: string,\n\tfieldType: DBFieldType,\n\tdbType: KyselyDatabaseType,\n) {\n\tfunction normalize(type: string) {\n\t\treturn type.toLowerCase().split(\"(\")[0]!.trim();\n\t}\n\tif (fieldType === \"string[]\" || fieldType === \"number[]\") {\n\t\treturn columnDataType.toLowerCase().includes(\"json\");\n\t}\n\tconst types = map[dbType]!;\n\tconst expected = Array.isArray(fieldType)\n\t\t? types[\"string\"].map((t) => t.toLowerCase())\n\t\t: types[fieldType]!.map((t) => t.toLowerCase());\n\treturn expected.includes(normalize(columnDataType));\n}\n\n/**\n * Get the current PostgreSQL schema (search_path) for the database connection\n * Returns the first schema in the search_path, defaulting to 'public' if not found\n */\nasync function getPostgresSchema(db: Kysely<unknown>): Promise<string> {\n\ttry {\n\t\tconst result = await sql<{ search_path: string }>`SHOW search_path`.execute(\n\t\t\tdb,\n\t\t);\n\t\tif (result.rows[0]?.search_path) {\n\t\t\t// search_path can be a comma-separated list like \"$user, public\" or '\"$user\", public'\n\t\t\t// We want the first non-variable schema\n\t\t\tconst schemas = result.rows[0].search_path\n\t\t\t\t.split(\",\")\n\t\t\t\t.map((s) => s.trim())\n\t\t\t\t// Remove quotes and filter out variables like $user\n\t\t\t\t.map((s) => s.replace(/^[\"']|[\"']$/g, \"\"))\n\t\t\t\t.filter((s) => !s.startsWith(\"$\"));\n\t\t\treturn schemas[0] || \"public\";\n\t\t}\n\t} catch {\n\t\t// If query fails, fall back to public schema\n\t}\n\treturn \"public\";\n}\n\nexport async function getMigrations(config: BetterAuthOptions) {\n\tconst betterAuthSchema = getSchema(config);\n\tconst logger = createLogger(config.logger);\n\n\tlet { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);\n\n\tif (!dbType) {\n\t\tlogger.warn(\n\t\t\t\"Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.\",\n\t\t);\n\t\tdbType = \"sqlite\";\n\t}\n\n\tif (!db) {\n\t\tlogger.error(\n\t\t\t\"Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n\n\t// For PostgreSQL, detect and log the current schema being used\n\tlet currentSchema = \"public\";\n\tif (dbType === \"postgres\") {\n\t\tcurrentSchema = await getPostgresSchema(db);\n\t\tlogger.debug(\n\t\t\t`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`,\n\t\t);\n\n\t\t// Verify the schema exists\n\t\ttry {\n\t\t\tconst schemaCheck = await sql<{ schema_name: string }>`\n\t\t\t\tSELECT schema_name \n\t\t\t\tFROM information_schema.schemata \n\t\t\t\tWHERE schema_name = ${currentSchema}\n\t\t\t`.execute(db);\n\n\t\t\tif (!schemaCheck.rows[0]) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.debug(\n\t\t\t\t`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst allTableMetadata = await db.introspection.getTables();\n\n\t// For PostgreSQL, filter tables to only those in the target schema\n\tlet tableMetadata = allTableMetadata;\n\tif (dbType === \"postgres\") {\n\t\t// Get tables with their schema information\n\t\ttry {\n\t\t\tconst tablesInSchema = await sql<{\n\t\t\t\ttable_name: string;\n\t\t\t}>`\n\t\t\t\tSELECT table_name \n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = ${currentSchema}\n\t\t\t\tAND table_type = 'BASE TABLE'\n\t\t\t`.execute(db);\n\n\t\t\tconst tableNamesInSchema = new Set(\n\t\t\t\ttablesInSchema.rows.map((row) => row.table_name),\n\t\t\t);\n\n\t\t\t// Filter to only tables that exist in the target schema\n\t\t\ttableMetadata = allTableMetadata.filter(\n\t\t\t\t(table) =>\n\t\t\t\t\ttable.schema === currentSchema && tableNamesInSchema.has(table.name),\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(\", \") || \"(none)\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.warn(\n\t\t\t\t`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t\t// Fall back to using all tables if schema filtering fails\n\t\t}\n\t}\n\tconst toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\tconst toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\n\tfor (const [key, value] of Object.entries(betterAuthSchema)) {\n\t\tconst table = tableMetadata.find((t) => t.name === key);\n\t\tif (!table) {\n\t\t\tconst tIndex = toBeCreated.findIndex((t) => t.table === key);\n\t\t\tconst tableData = {\n\t\t\t\ttable: key,\n\t\t\t\tfields: value.fields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t};\n\n\t\t\tconst insertIndex = toBeCreated.findIndex(\n\t\t\t\t(t) => (t.order || Infinity) > tableData.order,\n\t\t\t);\n\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tif (tIndex === -1) {\n\t\t\t\t\ttoBeCreated.push(tableData);\n\t\t\t\t} else {\n\t\t\t\t\ttoBeCreated[tIndex]!.fields = {\n\t\t\t\t\t\t...toBeCreated[tIndex]!.fields,\n\t\t\t\t\t\t...value.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoBeCreated.splice(insertIndex, 0, tableData);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tlet toBeAddedFields: Record<string, DBFieldAttribute> = {};\n\t\tfor (const [fieldName, field] of Object.entries(value.fields)) {\n\t\t\tconst column = table.columns.find((c) => c.name === fieldName);\n\t\t\tif (!column) {\n\t\t\t\ttoBeAddedFields[fieldName] = field;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (matchType(column.dataType, field.type, dbType)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(toBeAddedFields).length > 0) {\n\t\t\ttoBeAdded.push({\n\t\t\t\ttable: key,\n\t\t\t\tfields: toBeAddedFields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t});\n\t\t}\n\t}\n\n\tconst migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[] = [];\n\n\tconst useUUIDs = config.advanced?.database?.generateId === \"uuid\";\n\tconst useNumberId =\n\t\tconfig.advanced?.database?.useNumberId ||\n\t\tconfig.advanced?.database?.generateId === \"serial\";\n\n\tfunction getType(field: DBFieldAttribute, fieldName: string) {\n\t\tconst type = field.type;\n\t\tconst provider = dbType || \"sqlite\";\n\t\ttype StringOnlyUnion<T> = T extends string ? T : never;\n\t\tconst typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t> = {\n\t\t\tstring: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"text\",\n\t\t\t\tmysql: field.unique\n\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t: field.references\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: field.sortable\n\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t: field.index\n\t\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t\t: \"text\",\n\t\t\t\tmssql:\n\t\t\t\t\tfield.unique || field.sortable\n\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t: field.references\n\t\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t\t: // mssql deprecated `text`, and the alternative is `varchar(max)`.\n\t\t\t\t\t\t\t\t// Kysely type interface doesn't support `text`, so we set this to `varchar(8000)` as\n\t\t\t\t\t\t\t\t// that's the max length for `varchar`\n\t\t\t\t\t\t\t\t\"varchar(8000)\",\n\t\t\t},\n\t\t\tboolean: {\n\t\t\t\tsqlite: \"integer\",\n\t\t\t\tpostgres: \"boolean\",\n\t\t\t\tmysql: \"boolean\",\n\t\t\t\tmssql: \"smallint\",\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tsqlite: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tpostgres: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmysql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmssql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t},\n\t\t\tdate: {\n\t\t\t\tsqlite: \"date\",\n\t\t\t\tpostgres: \"timestamptz\",\n\t\t\t\tmysql: \"timestamp(3)\",\n\t\t\t\tmssql: sql`datetime2(3)`,\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\tid: {\n\t\t\t\tpostgres: useNumberId\n\t\t\t\t\t? sql`integer GENERATED BY DEFAULT AS IDENTITY`\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"uuid\"\n\t\t\t\t\t\t: \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\tforeignKeyId: {\n\t\t\t\tpostgres: useNumberId ? \"integer\" : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\" /* Should be using `UNIQUEIDENTIFIER` but Kysely doesn't support it */\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\t\"string[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\t\"number[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t} as const;\n\t\tif (fieldName === \"id\" || field.references?.field === \"id\") {\n\t\t\tif (fieldName === \"id\") {\n\t\t\t\treturn typeMap.id[provider];\n\t\t\t}\n\t\t\treturn typeMap.foreignKeyId[provider];\n\t\t}\n\t\tif (Array.isArray(type)) {\n\t\t\treturn \"text\";\n\t\t}\n\t\tif (!(type in typeMap)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported field type '${String(type)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: \"string\") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`,\n\t\t\t);\n\t\t}\n\t\treturn typeMap[type][provider];\n\t}\n\tconst getModelName = initGetModelName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\tconst getFieldName = initGetFieldName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\n\t// Helper function to safely resolve model and field names, falling back to\n\t// user-supplied strings for external tables not in the BetterAuth schema\n\tfunction getReferencePath(model: string, field: string): string {\n\t\ttry {\n\t\t\tconst modelName = getModelName(model);\n\t\t\tconst fieldName = getFieldName({ model, field });\n\t\t\treturn `${modelName}.${fieldName}`;\n\t\t} catch {\n\t\t\t// If resolution fails (external table), fall back to user-supplied references\n\t\t\treturn `${model}.${field}`;\n\t\t}\n\t}\n\n\tif (toBeAdded.length) {\n\t\tfor (const table of toBeAdded) {\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tlet builder = db.schema.alterTable(table.table);\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst index = db.schema\n\t\t\t\t\t\t.alterTable(table.table)\n\t\t\t\t\t\t.addIndex(`${table.table}_${fieldName}_idx`);\n\t\t\t\t\tmigrations.push(index);\n\t\t\t\t}\n\n\t\t\t\tlet built = builder.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\t\t\t\tmigrations.push(built);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet toBeIndexed: CreateIndexBuilder[] = [];\n\n\tif (config.advanced?.database?.useNumberId) {\n\t\tlogger.warn(\n\t\t\t\"`useNumberId` is deprecated. Please use `generateId` with `serial` instead.\",\n\t\t);\n\t}\n\n\tif (toBeCreated.length) {\n\t\tfor (const table of toBeCreated) {\n\t\t\tconst idType = getType({ type: useNumberId ? \"number\" : \"string\" }, \"id\");\n\t\t\tlet dbT = db.schema\n\t\t\t\t.createTable(table.table)\n\t\t\t\t.addColumn(\"id\", idType, (col) => {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\t// Identity column is already specified in the type via sql template tag\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"sqlite\") {\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"mssql\") {\n\t\t\t\t\t\t\treturn col.identity().primaryKey().notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.autoIncrement().primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\tif (useUUIDs) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\treturn col\n\t\t\t\t\t\t\t\t.primaryKey()\n\t\t\t\t\t\t\t\t.defaultTo(sql`pg_catalog.gen_random_uuid()`)\n\t\t\t\t\t\t\t\t.notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t});\n\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tdbT = dbT.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tlet builder = db.schema\n\t\t\t\t\t\t.createIndex(\n\t\t\t\t\t\t\t`${table.table}_${fieldName}_${field.unique ? \"uidx\" : \"idx\"}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.on(table.table)\n\t\t\t\t\t\t.columns([fieldName]);\n\t\t\t\t\ttoBeIndexed.push(field.unique ? builder.unique() : builder);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmigrations.push(dbT);\n\t\t}\n\t}\n\n\t// instead of adding the index straight to `migrations`,\n\t// we do this at the end so that indexes are created after the table is created\n\tif (toBeIndexed.length) {\n\t\tfor (const index of toBeIndexed) {\n\t\t\tmigrations.push(index);\n\t\t}\n\t}\n\n\tasync function runMigrations() {\n\t\tfor (const migration of migrations) {\n\t\t\tawait migration.execute();\n\t\t}\n\t}\n\tasync function compileMigrations() {\n\t\tconst compiled = migrations.map((m) => m.compile().sql);\n\t\treturn compiled.join(\";\\n\\n\") + \";\";\n\t}\n\treturn { toBeCreated, toBeAdded, runMigrations, compileMigrations };\n}\n"],"names":["logger","toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAddedFields: Record<string, DBFieldAttribute>","migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[]","typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t>","toBeIndexed: CreateIndexBuilder[]"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAqEA,MAAM,MAAM;IACX,UAhDmB;QACnB,QAAQ;YAAC;YAAqB;YAAW;YAAQ;SAAO;QACxD,QAAQ;YACP;YACA;YACA;YACA;YACA;YACA;YACA;SACA;QACD,SAAS;YAAC;YAAQ;SAAU;QAC5B,MAAM;YAAC;YAAe;YAAa;SAAO;QAC1C,MAAM;YAAC;YAAQ;SAAQ;KACvB;IAmCA,OAlCgB;QAChB,QAAQ;YAAC;YAAW;YAAQ;SAAO;QACnC,QAAQ;YACP;YACA;YACA;YACA;YACA;YACA;YACA;SACA;QACD,SAAS;YAAC;YAAW;SAAU;QAC/B,MAAM;YAAC;YAAa;YAAY;SAAO;QACvC,MAAM;YAAC;SAAO;KACd;IAqBA,QAnBiB;QACjB,QAAQ;YAAC;SAAO;QAChB,QAAQ;YAAC;YAAW;SAAO;QAC3B,SAAS;YAAC;YAAW;SAAU;QAC/B,MAAM;YAAC;YAAQ;SAAU;QACzB,MAAM;YAAC;SAAO;KACd;IAcA,OAZgB;QAChB,QAAQ;YAAC;YAAW;YAAY;SAAmB;QACnD,QAAQ;YAAC;YAAO;YAAU;YAAY;YAAW;YAAS;SAAS;QACnE,SAAS;YAAC;YAAO;SAAW;QAC5B,MAAM;YAAC;YAAa;YAAQ;SAAW;QACvC,MAAM;YAAC;YAAW;SAAW;KAC7B;CAOA;AAED,SAAgB,UACf,cAAA,EACA,SAAA,EACA,MAAA,EACC;IACD,SAAS,UAAU,IAAA,EAAc;QAChC,OAAO,KAAK,WAAA,EAAa,CAAC,KAAA,CAAM,IAAI,CAAC,EAAA,CAAI,IAAA,EAAM;;IAEhD,IAAI,cAAc,cAAc,cAAc,WAC7C,CAAA,OAAO,eAAe,WAAA,EAAa,CAAC,QAAA,CAAS,OAAO;IAErD,MAAM,QAAQ,GAAA,CAAI,OAAA;IAIlB,OAAA,CAHiB,MAAM,OAAA,CAAQ,UAAU,GACtC,KAAA,CAAM,SAAA,CAAU,GAAA,CAAA,CAAK,IAAM,EAAE,WAAA,EAAa,CAAC,GAC3C,KAAA,CAAM,UAAA,CAAY,GAAA,CAAA,CAAK,IAAM,EAAE,WAAA,EAAa,CAAC,EAChC,QAAA,CAAS,UAAU,eAAe,CAAC;;;;;GAOpD,eAAe,kBAAkB,EAAA,EAAsC;IACtE,IAAI;QACH,MAAM,SAAS,MAAM,4NAA4B,CAAA,gBAAA,CAAA,CAAmB,OAAA,CACnE,GACA;QACD,IAAI,OAAO,IAAA,CAAK,EAAA,EAAI,YASnB,CAAA,OANgB,OAAO,IAAA,CAAK,EAAA,CAAG,WAAA,CAC7B,KAAA,CAAM,IAAI,CACV,GAAA,CAAA,CAAK,IAAM,EAAE,IAAA,EAAM,CAAC,CAEpB,GAAA,CAAA,CAAK,IAAM,EAAE,OAAA,CAAQ,gBAAgB,GAAG,CAAC,CACzC,MAAA,CAAA,CAAQ,IAAM,CAAC,EAAE,UAAA,CAAW,IAAI,CAAC,CACpB,EAAA,IAAM;aAEf,CAAA;IAGR,OAAO;;AAGR,eAAsB,cAAc,MAAA,EAA2B;IAC9D,MAAM,uBAAmB,yXAAA,EAAU,OAAO;IAC1C,MAAMA,eAAS,waAAA,EAAa,OAAO,MAAA,CAAO;IAE1C,IAAI,EAAE,QAAQ,EAAA,EAAI,cAAc,MAAA,EAAA,GAAW,UAAM,wZAAA,EAAoB,OAAO;IAE5E,IAAI,CAAC,QAAQ;QACZ,SAAO,IAAA,CACN,wHACA;QACD,SAAS;;IAGV,IAAI,CAAC,IAAI;QACR,SAAO,KAAA,CACN,+IACA;QACD,QAAQ,IAAA,CAAK,EAAE;;IAIhB,IAAI,gBAAgB;IACpB,IAAI,WAAW,YAAY;QAC1B,gBAAgB,MAAM,kBAAkB,GAAG;QAC3C,SAAO,KAAA,CACN,CAAA,oCAAA,EAAuC,cAAc,oBAAA,CAAA,CACrD;QAGD,IAAI;YAOH,IAAI,CAAA,CANgB,MAAM,4NAA4B,CAAA;;;0BAG/B,cAAc;KACnC,OAAA,CAAQ,GAAG,EAEI,IAAA,CAAK,EAAA,CACrB,CAAA,SAAO,IAAA,CACN,CAAA,QAAA,EAAW,cAAc,8IAAA,CAAA,CACzB;iBAEM,OAAO;YACf,SAAO,KAAA,CACN,CAAA,mCAAA,EAAsC,iBAAiB,QAAQ,MAAM,OAAA,GAAU,OAAO,MAAM,EAAA,CAC5F;;;IAIH,MAAM,mBAAmB,MAAM,GAAG,aAAA,CAAc,SAAA,EAAW;IAG3D,IAAI,gBAAgB;IACpB,IAAI,WAAW,WAEd,CAAA,IAAI;QACH,MAAM,iBAAiB,MAAM,4NAE3B,CAAA;;;2BAGsB,cAAc;;KAEpC,OAAA,CAAQ,GAAG;QAEb,MAAM,qBAAqB,IAAI,IAC9B,eAAe,IAAA,CAAK,GAAA,CAAA,CAAK,MAAQ,IAAI,UAAA,CAAW,CAChD;QAGD,gBAAgB,iBAAiB,MAAA,CAAA,CAC/B,QACA,MAAM,MAAA,KAAW,iBAAiB,mBAAmB,GAAA,CAAI,MAAM,IAAA,CAAK,CACrE;QAED,SAAO,KAAA,CACN,CAAA,MAAA,EAAS,cAAc,MAAA,CAAO,qBAAA,EAAuB,cAAc,GAAA,EAAK,cAAc,GAAA,CAAA,CAAK,IAAM,EAAE,IAAA,CAAK,CAAC,IAAA,CAAK,KAAK,IAAI,UAAA,CACvH;aACO,OAAO;QACf,SAAO,IAAA,CACN,CAAA,uEAAA,EAA0E,iBAAiB,QAAQ,MAAM,OAAA,GAAU,OAAO,MAAM,EAAA,CAChI;;IAIH,MAAMC,cAIA,EAAE;IACR,MAAMC,YAIA,EAAE;IAER,KAAK,MAAM,CAAC,KAAK,MAAA,IAAU,OAAO,OAAA,CAAQ,iBAAiB,CAAE;QAC5D,MAAM,QAAQ,cAAc,IAAA,CAAA,CAAM,IAAM,EAAE,IAAA,KAAS,IAAI;QACvD,IAAI,CAAC,OAAO;YACX,MAAM,SAAS,YAAY,SAAA,CAAA,CAAW,IAAM,EAAE,KAAA,KAAU,IAAI;YAC5D,MAAM,YAAY;gBACjB,OAAO;gBACP,QAAQ,MAAM,MAAA;gBACd,OAAO,MAAM,KAAA,IAAS;aACtB;YAED,MAAM,cAAc,YAAY,SAAA,CAAA,CAC9B,IAAA,CAAO,EAAE,KAAA,IAAS,QAAA,IAAY,UAAU,KAAA,CACzC;YAED,IAAI,gBAAgB,CAAA,EACnB,CAAA,IAAI,WAAW,CAAA,EACd,CAAA,YAAY,IAAA,CAAK,UAAU;iBAE3B,WAAA,CAAY,OAAA,CAAS,MAAA,GAAS;gBAC7B,GAAG,WAAA,CAAY,OAAA,CAAS,MAAA;gBACxB,GAAG,MAAM,MAAA;aACT;iBAGF,YAAY,MAAA,CAAO,aAAa,GAAG,UAAU;YAE9C;;QAED,IAAIC,kBAAoD,CAAA,CAAE;QAC1D,KAAK,MAAM,CAAC,WAAW,MAAA,IAAU,OAAO,OAAA,CAAQ,MAAM,MAAA,CAAO,CAAE;YAC9D,MAAM,SAAS,MAAM,OAAA,CAAQ,IAAA,CAAA,CAAM,IAAM,EAAE,IAAA,KAAS,UAAU;YAC9D,IAAI,CAAC,QAAQ;gBACZ,eAAA,CAAgB,UAAA,GAAa;gBAC7B;;YAGD,IAAI,UAAU,OAAO,QAAA,EAAU,MAAM,IAAA,EAAM,OAAO,CACjD,CAAA;iBAEA,SAAO,IAAA,CACN,CAAA,MAAA,EAAS,UAAU,UAAA,EAAY,IAAI,gDAAA,EAAkD,MAAM,IAAA,CAAK,SAAA,EAAW,OAAO,QAAA,CAAS,CAAA,CAAA,CAC3H;;QAGH,IAAI,OAAO,IAAA,CAAK,gBAAgB,CAAC,MAAA,GAAS,EACzC,CAAA,UAAU,IAAA,CAAK;YACd,OAAO;YACP,QAAQ;YACR,OAAO,MAAM,KAAA,IAAS;SACtB,CAAC;;IAIJ,MAAMC,aAKA,EAAE;IAER,MAAM,WAAW,OAAO,QAAA,EAAU,UAAU,eAAe;IAC3D,MAAM,cACL,OAAO,QAAA,EAAU,UAAU,eAC3B,OAAO,QAAA,EAAU,UAAU,eAAe;IAE3C,SAAS,QAAQ,KAAA,EAAyB,SAAA,EAAmB;QAC5D,MAAM,OAAO,MAAM,IAAA;QACnB,MAAM,WAAW,UAAU;QAE3B,MAAMC,UAGF;YACH,QAAQ;gBACP,QAAQ;gBACR,UAAU;gBACV,OAAO,MAAM,MAAA,GACV,iBACA,MAAM,UAAA,GACL,gBACA,MAAM,QAAA,GACL,iBACA,MAAM,KAAA,GACL,iBACA;gBACN,OACC,MAAM,MAAA,IAAU,MAAM,QAAA,GACnB,iBACA,MAAM,UAAA,GACL,gBAID;aACJ;YACD,SAAS;gBACR,QAAQ;gBACR,UAAU;gBACV,OAAO;gBACP,OAAO;aACP;YACD,QAAQ;gBACP,QAAQ,MAAM,MAAA,GAAS,WAAW;gBAClC,UAAU,MAAM,MAAA,GAAS,WAAW;gBACpC,OAAO,MAAM,MAAA,GAAS,WAAW;gBACjC,OAAO,MAAM,MAAA,GAAS,WAAW;aACjC;YACD,MAAM;gBACL,QAAQ;gBACR,UAAU;gBACV,OAAO;gBACP,OAAO,4NAAG,CAAA,YAAA,CAAA;aACV;YACD,MAAM;gBACL,QAAQ;gBACR,UAAU;gBACV,OAAO;gBACP,OAAO;aACP;YACD,IAAI;gBACH,UAAU,cACP,4NAAG,CAAA,wCAAA,CAAA,GACH,WACC,SACA;gBACJ,OAAO,cACJ,YACA,WACC,gBACA;gBACJ,OAAO,cACJ,YACA,WACC,gBACA;gBACJ,QAAQ,cAAc,YAAY;aAClC;YACD,cAAc;gBACb,UAAU,cAAc,YAAY,WAAW,SAAS;gBACxD,OAAO,cACJ,YACA,WACC,gBACA;gBACJ,OAAO,cACJ,YACA,WACC,gBACA;gBACJ,QAAQ,cAAc,YAAY;aAClC;YACD,YAAY;gBACX,QAAQ;gBACR,UAAU;gBACV,OAAO;gBACP,OAAO;aACP;YACD,YAAY;gBACX,QAAQ;gBACR,UAAU;gBACV,OAAO;gBACP,OAAO;aACP;SACD;QACD,IAAI,cAAc,QAAQ,MAAM,UAAA,EAAY,UAAU,MAAM;YAC3D,IAAI,cAAc,KACjB,CAAA,OAAO,QAAQ,EAAA,CAAG,SAAA;YAEnB,OAAO,QAAQ,YAAA,CAAa,SAAA;;QAE7B,IAAI,MAAM,OAAA,CAAQ,KAAK,CACtB,CAAA,OAAO;QAER,IAAI,CAAA,CAAE,QAAQ,OAAA,EACb,CAAA,MAAM,IAAI,MACT,CAAA,wBAAA,EAA2B,OAAO,KAAK,CAAC,aAAA,EAAe,UAAU,+PAAA,CAAA,CACjE;QAEF,OAAO,OAAA,CAAQ,KAAA,CAAM,SAAA;;IAEtB,MAAM,mBAAe,8YAAA,EAAiB;QACrC,YAAQ,obAAA,EAAc,OAAO;QAC7B,WAAW;KACX,CAAC;IACF,MAAM,mBAAe,8YAAA,EAAiB;QACrC,YAAQ,obAAA,EAAc,OAAO;QAC7B,WAAW;KACX,CAAC;IAIF,SAAS,iBAAiB,KAAA,EAAe,KAAA,EAAuB;QAC/D,IAAI;YAGH,OAAO,GAFW,aAAa,MAAM,CAEjB,CAAA,EADF,aAAa;gBAAE;gBAAO;aAAO,CAAC,EAAA;iBAEzC;YAEP,OAAO,GAAG,MAAM,CAAA,EAAG,OAAA;;;IAIrB,IAAI,UAAU,MAAA,CACb,CAAA,KAAK,MAAM,SAAS,UACnB,KAAK,MAAM,CAAC,WAAW,MAAA,IAAU,OAAO,OAAA,CAAQ,MAAM,MAAA,CAAO,CAAE;QAC9D,MAAM,OAAO,QAAQ,OAAO,UAAU;QACtC,IAAI,UAAU,GAAG,MAAA,CAAO,UAAA,CAAW,MAAM,KAAA,CAAM;QAE/C,IAAI,MAAM,KAAA,EAAO;YAChB,MAAM,QAAQ,GAAG,MAAA,CACf,UAAA,CAAW,MAAM,KAAA,CAAM,CACvB,QAAA,CAAS,GAAG,MAAM,KAAA,CAAM,CAAA,EAAG,UAAU,IAAA,CAAA,CAAM;YAC7C,WAAW,IAAA,CAAK,MAAM;;QAGvB,IAAI,QAAQ,QAAQ,SAAA,CAAU,WAAW,MAAA,CAAO,QAAQ;YACvD,MAAM,MAAM,QAAA,KAAa,QAAQ,IAAI,OAAA,EAAS,GAAG;YACjD,IAAI,MAAM,UAAA,CACT,CAAA,MAAM,IACJ,UAAA,CACA,iBACC,MAAM,UAAA,CAAW,KAAA,EACjB,MAAM,UAAA,CAAW,KAAA,CACjB,CACD,CACA,QAAA,CAAS,MAAM,UAAA,CAAW,QAAA,IAAY,UAAU;YAEnD,IAAI,MAAM,MAAA,CACT,CAAA,MAAM,IAAI,MAAA,EAAQ;YAEnB,IACC,MAAM,IAAA,KAAS,UACf,OAAO,MAAM,YAAA,KAAiB,cAAA,CAC7B,WAAW,cAAc,WAAW,WAAW,WAAW,OAAA,EAE3D,CAAA,IAAI,WAAW,QACd,CAAA,MAAM,IAAI,SAAA,CAAU,4NAAG,CAAA,oBAAA,CAAA,CAAuB;iBAE9C,MAAM,IAAI,SAAA,CAAU,4NAAG,CAAA,iBAAA,CAAA,CAAoB;YAG7C,OAAO;UACN;QACF,WAAW,IAAA,CAAK,MAAM;;IAKzB,IAAIC,cAAoC,EAAE;IAE1C,IAAI,OAAO,QAAA,EAAU,UAAU,YAC9B,CAAA,SAAO,IAAA,CACN,8EACA;IAGF,IAAI,YAAY,MAAA,CACf,CAAA,KAAK,MAAM,SAAS,YAAa;QAChC,MAAM,SAAS,QAAQ;YAAE,MAAM,cAAc,WAAW;QAAA,CAAU,EAAE,KAAK;QACzE,IAAI,MAAM,GAAG,MAAA,CACX,WAAA,CAAY,MAAM,KAAA,CAAM,CACxB,SAAA,CAAU,MAAM,QAAA,CAAS,QAAQ;YACjC,IAAI,aAAa;gBAChB,IAAI,WAAW,WAEd,CAAA,OAAO,IAAI,UAAA,EAAY,CAAC,OAAA,EAAS;yBACvB,WAAW,SACrB,CAAA,OAAO,IAAI,UAAA,EAAY,CAAC,OAAA,EAAS;yBACvB,WAAW,QACrB,CAAA,OAAO,IAAI,QAAA,EAAU,CAAC,UAAA,EAAY,CAAC,OAAA,EAAS;gBAE7C,OAAO,IAAI,aAAA,EAAe,CAAC,UAAA,EAAY,CAAC,OAAA,EAAS;;YAElD,IAAI,UAAU;gBACb,IAAI,WAAW,WACd,CAAA,OAAO,IACL,UAAA,EAAY,CACZ,SAAA,CAAU,4NAAG,CAAA,4BAAA,CAAA,CAA+B,CAC5C,OAAA,EAAS;gBAEZ,OAAO,IAAI,UAAA,EAAY,CAAC,OAAA,EAAS;;YAElC,OAAO,IAAI,UAAA,EAAY,CAAC,OAAA,EAAS;UAChC;QAEH,KAAK,MAAM,CAAC,WAAW,MAAA,IAAU,OAAO,OAAA,CAAQ,MAAM,MAAA,CAAO,CAAE;YAC9D,MAAM,OAAO,QAAQ,OAAO,UAAU;YACtC,MAAM,IAAI,SAAA,CAAU,WAAW,MAAA,CAAO,QAAQ;gBAC7C,MAAM,MAAM,QAAA,KAAa,QAAQ,IAAI,OAAA,EAAS,GAAG;gBACjD,IAAI,MAAM,UAAA,CACT,CAAA,MAAM,IACJ,UAAA,CACA,iBACC,MAAM,UAAA,CAAW,KAAA,EACjB,MAAM,UAAA,CAAW,KAAA,CACjB,CACD,CACA,QAAA,CAAS,MAAM,UAAA,CAAW,QAAA,IAAY,UAAU;gBAGnD,IAAI,MAAM,MAAA,CACT,CAAA,MAAM,IAAI,MAAA,EAAQ;gBAEnB,IACC,MAAM,IAAA,KAAS,UACf,OAAO,MAAM,YAAA,KAAiB,cAAA,CAC7B,WAAW,cAAc,WAAW,WAAW,WAAW,OAAA,EAE3D,CAAA,IAAI,WAAW,QACd,CAAA,MAAM,IAAI,SAAA,CAAU,4NAAG,CAAA,oBAAA,CAAA,CAAuB;qBAE9C,MAAM,IAAI,SAAA,CAAU,4NAAG,CAAA,iBAAA,CAAA,CAAoB;gBAG7C,OAAO;cACN;YAEF,IAAI,MAAM,KAAA,EAAO;gBAChB,IAAI,UAAU,GAAG,MAAA,CACf,WAAA,CACA,GAAG,MAAM,KAAA,CAAM,CAAA,EAAG,UAAU,CAAA,EAAG,MAAM,MAAA,GAAS,SAAS,OAAA,CACvD,CACA,EAAA,CAAG,MAAM,KAAA,CAAM,CACf,OAAA,CAAQ;oBAAC;iBAAU,CAAC;gBACtB,YAAY,IAAA,CAAK,MAAM,MAAA,GAAS,QAAQ,MAAA,EAAQ,GAAG,QAAQ;;;QAG7D,WAAW,IAAA,CAAK,IAAI;;IAMtB,IAAI,YAAY,MAAA,CACf,CAAA,KAAK,MAAM,SAAS,YACnB,WAAW,IAAA,CAAK,MAAM;IAIxB,eAAe,gBAAgB;QAC9B,KAAK,MAAM,aAAa,WACvB,MAAM,UAAU,OAAA,EAAS;;IAG3B,eAAe,oBAAoB;QAElC,OADiB,WAAW,GAAA,CAAA,CAAK,IAAM,EAAE,OAAA,EAAS,CAAC,GAAA,CAAI,CACvC,IAAA,CAAK,QAAQ,GAAG;;IAEjC,OAAO;QAAE;QAAa;QAAW;QAAe;KAAmB"}},
    {"offset": {"line": 1546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/better-auth@1.4.9_drizzle-kit@0.31.8_drizzle-orm@0.45.1_@opentelemetry+api@1.9.0_@types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/dist/db/index.mjs","sources":["file:///Users/aunogarafat/Work/conversation/app/web/node_modules/.pnpm/better-auth%401.4.9_drizzle-kit%400.31.8_drizzle-orm%400.45.1_%40opentelemetry%2Bapi%401.9.0_%40types_2c2f84378f2ef24b1a7bf909953e43a4/node_modules/better-auth/src/db/index.ts"],"sourcesContent":["export * from \"@better-auth/core/db\";\nexport * from \"./adapter-base\";\nexport * from \"./adapter-kysely\";\nexport * from \"./field\";\nexport * from \"./field-converter\";\nexport * from \"./get-migration\";\nexport * from \"./get-schema\";\nexport * from \"./internal-adapter\";\nexport * from \"./schema\";\nexport * from \"./to-zod\";\nexport * from \"./with-hooks\";\n"],"names":[],"mappings":""}}]
}